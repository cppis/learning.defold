local rendercam = require "rendercam.rendercam"
local gesture = require "in.gesture"
local debugdraw = require "debug-draw.debug-draw"


local zstep = 10

function init(self)
	print("acquire input focus...")
	msg.post(".", "acquire_input_focus")
	gesture.SETTINGS.double_tap_interval = 1
	self.points = {}
end

function update(self, dt)
	local prev = nil
	for k,curr in pairs(self.points) do
		if nil ~= prev then
			--debugdraw.line(vmath.vector3(prev.x, prev.y, 0), vmath.vector3(curr.x, curr.y, 1))
			debugdraw.line(prev.x, prev.y, curr.x, curr.y)
		end

		prev = curr
	end
end

function on_input(self, action_id, action)
	--local g = gesture.on_input(self, action_id, action)
	
	if action_id == hash("Touch") and action.pressed then
		-- rendercam position
		local pos = rendercam.screen_to_world_2d(action.screen_x, action.screen_y)
		-- default position
		--local pos = vmath.vector3(action.x, action.y, 0)
		--print("touch pos x:" .. action.x .. ", y:" .. action.y)
		local id = factory.create("/go#factory", pos)
		go.set_position(pos, id)
		table.insert(self.points, pos)
		--go.animate(id, "position.x", go.PLAYBACK_ONCE_FORWARD, 720, go.EASING_LINEAR, 3)

	elseif action_id == hash("WheelUp") then
		rendercam.zoom(-zstep)

	elseif action_id == hash("WheelDown") then
		rendercam.zoom(zstep)

	end
end

function on_message(self, message_id, message)
	if message_id == hash("remove_point") then
		--print("remove point...")
		
		head = table.remove(self.points, 1)
	end
end
